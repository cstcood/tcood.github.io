<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[c语言结构体分析]]></title>
    <url>%2Fcategory%2Fc%E8%AF%AD%E8%A8%80%E7%BB%93%E6%9E%84%E4%BD%93%E5%88%86%E6%9E%90%2F</url>
    <content type="text"><![CDATA[基本框架代码表示123456789101112131415161718192021//构建结构体struct Name&#123;int num;char str[100];…………&#125;;//创建结构体struct Name name1;//创建单个结构体struct Name name2[40];//创建多个结构体【数组】/*结构体元素调用etc: name1.num name2[0].str*///结构体元素初始化strcpy(name1.str,*str)name2[0].num=0; 内存区域表示 复合结构体表示1234567891011121314151617181920//初始化struct father&#123;int num;char str[100];……………… struct child child1;&#125;;struct child&#123;int num1;char str1[100];………………&#125;//初始化struct father f;//赋值f.chlid1.num1=0; 举例 学生成绩录入与筛选 123456789101112131415161718192021222324252627282930313233343536typedef struct student//typedef 定义新的数据类型&#123; char name[20];//学生姓名 float score;//学生成绩&#125;student;void process3()&#123; int n; float total=0,avr; student std[40]; printf("***********************\n"); printf("please enter the number of student\n"); scanf("%d",&amp;n);//输入录入学生的个数 for(int i=0; i&lt;n; i++)//循环录入 &#123; printf("please enter the name of %d student\n",i+1); scanf("%s",std[i].name); printf("please enter the score of %d student\n",i+1); scanf("%f",&amp;std[i].score); //printf("%f",std[i].score); total+=std[i].score;//计算总成绩 &#125; avr=total/(float)n;//计算平均成绩 printf("the socre more than average \n"); for(int i=0; i&lt;n; i++)//输出结果 &#123; if(std[i].score&gt;avr) printf("the name is:%s socre is %.2f \n",std[i].name,std[i].score); &#125;&#125;]]></content>
      <categories>
        <category>c语言</category>
        <category>结构体</category>
      </categories>
      <tags>
        <tag>c语言</tag>
        <tag>结构体</tag>
        <tag>oo</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[关于全排列与深度搜索的分析]]></title>
    <url>%2Fcategory%2F%E5%85%B3%E4%BA%8E%E5%85%A8%E6%8E%92%E5%88%97%E4%B8%8E%E6%B7%B1%E5%BA%A6%E6%90%9C%E7%B4%A2%E7%9A%84%E5%88%86%E6%9E%90%2F</url>
    <content type="text"><![CDATA[定义全排列的生成算法方法是将给定的序列中所有可能的全排列无重复无遗漏地枚举出来。此处全排列的定义是：从n个元素中取出m个元素进行排列，当n=m时这个排列被称为全排列。 举例input:初始数值1,2,3 1234567output:[1,2,3][1,3,2][2,1,3][2,3,1][3,1,2][3,2,1] 实现方法交换法， 选择插入法 代码实现1234567891011121314151617181920212223242526void sweap(int *a,int *b)&#123; int t; t=*a; *a=*b; *b=t;&#125;int list(int *a,int min,int max)&#123; if(min==max-1)//递归到最后一项无需交换直接输出 &#123; for(int i=0; i&lt;max; i++) printf("%d",a[i]); printf("\n"); &#125; else &#123; for(int i=min; i&lt;max; i++)//次次与后面的项进行交换 &#123; sweap(&amp;a[i],&amp;a[min]); list(a,min+1,max); sweap(&amp;a[i],&amp;a[min]);//递归完成退栈还原 &#125; &#125;&#125; 123456789101112131415161718192021222324252627282930313233343536373839void pre(int *a,int *b,int cur,int max)//从b[]遍历选择a[]中第cur位的数字 &#123; int mark=0; if(cur==max)//插入到最后一项无需插入 &#123; for(int i=0; i&lt;max; i++) printf("%d ",a[i]); printf("\n"); &#125; else &#123; for(int i=0; i&lt;max; i++)//遍历b[]每一项数字 &#123; mark=0; for(int j=0; j&lt;cur; j++) &#123; if(b[i]==a[j])//去重 &#123; mark=1; break; &#125; &#125; if(mark==0) &#123; a[cur]=b[i]; pre(a,b,cur+1,max); &#125; &#125; &#125;&#125;]]></content>
      <categories>
        <category>算法</category>
        <category>c语言</category>
      </categories>
      <tags>
        <tag>全排列</tag>
        <tag>递归</tag>
        <tag>深度搜索</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[递归的学习]]></title>
    <url>%2Fcategory%2F%E9%80%92%E5%BD%92%E7%9A%84%E5%AD%A6%E4%B9%A0%2F</url>
    <content type="text"><![CDATA[关于递归的初步原理 程序自己家调用自己的过程叫做递归 流程图演示 ### 基础代码实现 1234567void fun(int a)&#123; fun(a);&#125; tip:此处递归没有加入结束条件为死循环递归法 例子斐波拉契数列f(n) = f(n-1)+f(n-2)12345int fibonacci(int n)&#123;if(n==1||n==2) return 1; //斐波拉契数列初始化前两项的额值为2return fibonacci(n-1)+fibonacci(n-2);//前两项相加和作为下一项&#125; 猴子吃桃问题解析123456789101112void monkeyproblem(int day)&#123; static int sum=1; if(day==1) printf("%d",sum); else &#123; sum=(sum+1)*2; f(day-1);&#125; 内存分析Tip: 0x00401507 &lt;+7&gt;: cmp DWORD PTR [ebp+0x8],0x1为斐波拉契数列中的比较输入值与输出值的部分 0x0040151a &lt;+26&gt;: mov eax,DWORD PTR [ebp+0x8]为不满足时的返回部分 关于非递归法的堆栈表示法12345678910111213141516171819202122int nfact()&#123; int res; PSeqStack sd; st=createEmptyStack_seq(); while(n&gt;0) &#123; push_seq(st,n); n=n-1; &#125; res=1; while(!isEmptyStack_seq(st)) &#123; res=res*top-seq(st); pop_seq(st); &#125; free(st); return(res);&#125;]]></content>
      <tags>
        <tag>c语言</tag>
        <tag>递归</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[数组排序]]></title>
    <url>%2Fcategory%2F%E6%95%B0%E7%BB%84%E6%8E%92%E5%BA%8F%2F</url>
    <content type="text"><![CDATA[冒泡排序原理图 代码实现方法123456789101112131415#include &lt;stdiol.h&gt;int main()&#123; int a[100],temp; //初始化大小为100的数组 for(int i=0;i&lt;100;i++) for(int j=0;j&lt;100-i;j++) &#123; if(a[j]&gt;a[j+1]) &#123; temp=[j]; a[j]=a[j+1]; a[j+1]=temp; &#125; &#125; } 插入排序原理图 代码实现方法123456789101112131415#include &lt;stdiol.h&gt;int main()&#123; int a[100],temp; //初始化大小为100的数组 for(int i=1;i&lt;100;i++) for(int j=i-i;j&gt;=0;j--) &#123; if(a[j]&gt;a[j+1]) &#123; temp=[j]; a[j]=a[j+1]; a[j+1]=temp; &#125; &#125;]]></content>
      <categories>
        <category>c语言</category>
        <category>算法</category>
      </categories>
      <tags>
        <tag>c语言</tag>
        <tag>排序</tag>
        <tag>冒泡</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[for循环详解]]></title>
    <url>%2Fcategory%2Ffor%E5%BE%AA%E7%8E%AF%E8%AF%A6%E8%A7%A3%2F</url>
    <content type="text"><![CDATA[for循环框架for(expectation 1;expecatation 2;expectation 3)为其基本框架 流程原理1234567891011121314151617flowchatst=&gt;start:开始;op=&gt;operation: for(expectation 1;expecatation 2;expectation 3);op1=&gt;operation: expectation 1;op3=&gt;operation: others;op2=&gt;operation: expectation 3;co-&gt;condition: expecatation 2 is true?;op1=operation:ed-&gt;end:结束;st-&gt;op-&gt;op1-&gt;co;co(yes)-&gt;op3-&gt;op2-&gt;co;co(no)-&gt;ed;]]></content>
      <categories>
        <category>c语言，函数</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[链表详解]]></title>
    <url>%2Fcategory%2F%E9%93%BE%E8%A1%A8%E8%AF%A6%E8%A7%A3%2F</url>
    <content type="text"><![CDATA[结构体初始化123456struct data &#123; int a;//存储数据 struct data *next;//存储下一个节点的地址 struct data *preview;//存储上一个节点的地址&#125;; 初始化data结构体 data *next存储下一个结构体函数的地址data *preview存储下一个结构体函数的地址a代表存储的数据 创建空链表1234567891011121314151617181920212223242526272829303132333435363738394041424344struct data *creatlist()&#123; struct data* head,*p1,*p2; n=0; p1=p2=(struct data *)malloc(sizeof(struct data));//给空间链表开辟内存 scanf("%d",&amp;p1-&gt;a);//读入第一个数据 while(p1-&gt;a!=0)//判断数据是否为null &#123; n++; if(n==1) &#123;s head=p1;//确立首节点地址 head-&gt;preview=NULL;//首节点前节点为空 &#125; else &#123; p1=(struct data *)malloc(sizeof(struct data));//开辟下一个内存空间 scanf("%d",&amp;p1-&gt;a);//键入数据 p2-&gt;next=p1;//完善上一个节点的链接 p1-&gt;preview=p2;//完善下一个节点的链接 p2=p1;//辅助变量转移 &#125; &#125; p1-&gt;next=NULL; end=p1-&gt;preview; return head;&#125;``` `struct data *creatlist()`函数返回链表首节点的地址### 单项链表顺序输出```cvoid printlist(struct data *g)&#123; struct data *p1 = g; //传递变量 while(p1-&gt;next!=NULL) //判断是否为尾节点 &#123; printf(" %d ",p1-&gt;a); p1=p1-&gt;next;//节点移动 &#125;&#125; void printlist(struct data *g)按序输出链表中的每个元素 双向链表逆向输出123456789101112void printlistA(struct data *g)&#123; struct data *p1 = g;//传递变量 printf("\n"); while(p1-&gt;preview!=NULL)//判断是否为首节点 &#123; printf(" %d ",p1-&gt;a);//输出节点内容 p1=p1-&gt;preview;//节点前移 &#125; printf(" %d ",p1-&gt;a);&#125; void printlistA(struct data *g)逆向输出节点的数据 修改链表某一项的内容1234567891011121314void changelist(struct data *g, int n)&#123; struct data *p1 = g;//传递变量 int i=1;//定义下标 int data;//定义输入的内容 for(i; i&lt;n; i++) &#123; p1=p1-&gt;next;//移动节点 &#125; scanf("%d",&amp;data);//输入内容 p1-&gt;a=data;//修改内容&#125; void changelist(struct data *g, int n)修改链表内容函数 添加链表某一项的内容12345678910111213141516171819void addlist(struct data *g, int n)&#123; struct data *p1 = g;//传递变量 struct data *p2; struct data *new; int i=1; int data; for(i; i&lt;n; i++) //节点转移 &#123; p1=p1-&gt;next; &#125; p2=p1-&gt;next; new=(struct data *)malloc(sizeof(struct data));//分配空间 scanf("%d",&amp;new-&gt;a); p1-&gt;next=new; new-&gt;next=p2;//链表连接&#125; 删除链表中某个数据1234567891011121314151617181920void deletelist(struct data *g, int n)&#123; struct data *p1 = g; struct data *temp; struct data *p2; int i=1; for(i; i&lt;n; i++) &#123; p1=p1-&gt;next; &#125; temp=p1-&gt;next;//取目标链表 p2=temp-&gt;next;//取目标下一个链表 p1-&gt;next=p2;//链表连接 free(temp);//释放空间&#125;]]></content>
      <categories>
        <category>数据结构</category>
        <category>c语言</category>
      </categories>
      <tags>
        <tag>c语言</tag>
        <tag>链表</tag>
        <tag>数据结构</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[b站测试]]></title>
    <url>%2Fcategory%2Fb%E7%AB%99%E6%B5%8B%E8%AF%95%2F</url>
    <content type="text"><![CDATA[coding:1&lt;iframe src="//player.bilibili.com/player.html?aid=34336721&amp;cid=:60148621&amp;page=1" scrolling="no" border="0" frameborder="no" framespacing="0" allowfullscreen="true" width=100% height=450&gt; &lt;/iframe&gt;]]></content>
      <categories>
        <category>测试</category>
      </categories>
      <tags>
        <tag>测试</tag>
        <tag>框架</tag>
        <tag>补番</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Blog Web update]]></title>
    <url>%2Fcategory%2FBlog-Web-update%2F</url>
    <content type="text"><![CDATA[creat musicpalyersource:NetEase Cloud Music. 评论组件 source:Livere delete blank link delete blank link add SEO]]></content>
      <categories>
        <category>框架更新</category>
      </categories>
      <tags>
        <tag>更新</tag>
        <tag>维护</tag>
        <tag>主题</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[my new blog1 test]]></title>
    <url>%2Fcategory%2Fmy-new-blog1-test%2F</url>
    <content type="text"><![CDATA[the first new 1.creat a new blog test text at local mechine 2.creat this text(.md) 3.start at local mechine polish the style site: https://github.com/litten/hexo-theme-yilia]]></content>
  </entry>
  <entry>
    <title><![CDATA[关于链表的学习]]></title>
    <url>%2Fcategory%2F%E5%85%B3%E4%BA%8E%E9%93%BE%E8%A1%A8%E7%9A%84%E5%AD%A6%E4%B9%A0%2F</url>
    <content type="text"><![CDATA[关于链表的简介链表是一种物理存储单元上非连续、非顺序的存储结构，数据元素的逻辑顺序是通过链表中的指针链接次序实现的。链表由一系列结点（链表中每一个元素称为结点）组成，结点可以在运行时动态生成。每个结点包括两个部分：一个是存储数据元素的数据域，另一个是存储下一个结点地址的指针域。 相比于线性表顺序结构，操作复杂。由于不必须按顺序存储，链表在插入的时候可以达到O(1)的复杂度，比另一种线性表顺序表快得多，但是查找一个节点或者访问特定编号的节点则需要O(n)的时间，而线性表和顺序表相应的时间复杂度分别是O(logn)和O(1)。 链表基础框架 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156#include&lt;stdio.h&gt;#include&lt;stdlib.h&gt;int n=0;struct data &#123; int a; struct data *next; struct data *preview;&#125;;struct data *end;struct data *creatlist();void printlist(struct data *g);void printAdress(struct data *g);void printlistA(struct data *g);void changelist(struct data *g, int n);void addlist(struct data *g, int n);void deletelist(struct data *g, int n);int main()&#123; struct data *head; head=creatlist(); printf("%p \n",head); printlist(head); printlistA(end); changelist(head,3); printlist(head); addlist(head,3); printlist(head); printf("\n"); deletelist(head,2); printlist(head); printf("\n"); printAdress(head); return 0;&#125;struct data *creatlist()&#123; struct data* head,*p1,*p2; n=0; p1=p2=(struct data *)malloc(sizeof(struct data)); scanf("%d",&amp;p1-&gt;a); while(p1-&gt;a!=0) &#123; n++; if(n==1) &#123; head=p1; head-&gt;preview=NULL; &#125; else &#123; p1=(struct data *)malloc(sizeof(struct data)); scanf("%d",&amp;p1-&gt;a); p2-&gt;next=p1; p1-&gt;preview=p2; p2=p1; &#125; &#125; p1-&gt;next=NULL; end=p1-&gt;preview; return head;&#125;void printlist(struct data *g)&#123; struct data *p1 = g; while(p1-&gt;next!=NULL) &#123; printf(" %d ",p1-&gt;a); p1=p1-&gt;next; &#125;&#125;void printlistA(struct data *g)&#123; struct data *p1 = g; printf("\n"); while(p1-&gt;preview!=NULL) &#123; printf(" %d ",p1-&gt;a); p1=p1-&gt;preview; &#125; printf(" %d ",p1-&gt;a);&#125;void printAdress(struct data *g)&#123; struct data *p1 = g; while(p1-&gt;next!=NULL) &#123; printf(" %p ",&amp;p1); p1=p1-&gt;next; &#125;&#125;void changelist(struct data *g, int n)&#123; struct data *p1 = g; int i=1; int data; for(i; i&lt;n; i++) &#123; p1=p1-&gt;next; &#125; scanf("%d",&amp;data); p1-&gt;a=data;&#125;void addlist(struct data *g, int n)&#123; struct data *p1 = g; struct data *p2; struct data *new; int i=1; int data; for(i; i&lt;n; i++) &#123; p1=p1-&gt;next; &#125; p2=p1-&gt;next; new=(struct data *)malloc(sizeof(struct data)); scanf("%d",&amp;new-&gt;a); p1-&gt;next=new; new-&gt;next=p2;&#125;void deletelist(struct data *g, int n)&#123; struct data *p1 = g; struct data *temp; struct data *p2; int i=1; for(i; i&lt;n; i++) &#123; p1=p1-&gt;next; &#125; temp=p1-&gt;next; p2=temp-&gt;next; p1-&gt;next=p2; free(temp);&#125; 更多详情链表详解]]></content>
      <categories>
        <category>c语言</category>
        <category>算法</category>
      </categories>
      <tags>
        <tag>c语言</tag>
        <tag>链表</tag>
        <tag>数据结构</tag>
      </tags>
  </entry>
</search>
